<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>UICollectionView居中无限循环</title>
    <link rel="stylesheet" href="../pageStyle.css" media="all">
    <link rel="stylesheet" href="../article.css" media="all">
</head>
<body>
    <div class="article">
        <h1 class="title">UICollectionView居中无限循环</h1>
        <blockquote><p>使用UICollectionView实现无限循环效果，通过重写FlowLayout让视图居中显示，并且在滑动过程中存在缩放效果，视图越接近屏幕中心越大</p></blockquote>
        <h2>一、实现效果</h2>
        <img class="image-view" src="../Resource/CollectionViewCenterCircle_1.png">
        <h2>二、实现滑动缩放效果</h2>
        <p>需要重写FlowLayout中的<code class="text-code">- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect</code>方法，该方法是用来显示cell的布局的，具体实现逻辑如下：</p>
        <pre><code class="Objective-C">- (nullable NSArray<__kindof UICollectionViewLayoutAttributes *> *)layoutAttributesForElementsInRect:(CGRect)rect
{

    //1.确定加载item的区域
    CGFloat  x = self.collectionView.contentOffset.x;
    CGFloat  y = 0;
    CGFloat  w = self.collectionView.frame.size.width;
    CGFloat  h = self.collectionView.frame.size.height;
    CGRect myrect =CGRectMake(x, y, w, h);

    //2.获得这个区域的item
    NSArray *original =[super layoutAttributesForElementsInRect:myrect];

    //遍历item,快到中间的时候放大，离开中间的时候收索
    for (UICollectionViewLayoutAttributes *atts in original) {
        CGFloat collectionCenterX = self.collectionView.contentOffset.x + self.collectionView.frame.size.width / 2.;
        CGFloat offset = fabs(atts.center.x - collectionCenterX) / self.itemSize.width;
        CGFloat scale = 1 - MIN(offset, 1) * 0.1;

        atts.transform =CGAffineTransformMakeScale(scale, scale);
    }
    NSArray * attributes = [[NSArray alloc] initWithArray:original copyItems:YES];

    return attributes;
}</code></pre>
        <p>若继承UICollectionViewFlowLayout需要重写<code class="text-code">- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds</code>方法，因为FlowLayout默认为false，而collectionViewLayout默认为true</p>
        <pre><code class="Objective-C">- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds;
{
    return YES;
}</code></pre>
        <h2>三、实现居中效果</h2>
        <p>通过从写<code class="text-code">- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity</code>方法实现Item的细节计算，完成定位处理<br>
        此方法是在网上找到的，虽然比较复杂但是滑动起来相对比较流畅，而且无定位错误、卡顿等bug</p>
        <pre><code class="Objective-C">- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity
{
    CGFloat offSetAdjustment = MAXFLOAT;
    CGFloat horizontalCenter = (CGFloat) (proposedContentOffset.x + (self.collectionView.bounds.size.width / 2.0));

    CGRect targetRect = CGRectMake(proposedContentOffset.x, 0.0, self.collectionView.bounds.size.width, self.collectionView.bounds.size.height);

    NSArray *array = [self layoutAttributesForElementsInRect:targetRect];

    UICollectionViewLayoutAttributes *currentAttributes;

    for (UICollectionViewLayoutAttributes *layoutAttributes in array)
    {
        if(layoutAttributes.representedElementCategory == UICollectionElementCategoryCell)
        {
            CGFloat itemHorizontalCenter = layoutAttributes.center.x;
            if (ABS(itemHorizontalCenter - horizontalCenter) <  ABS(offSetAdjustment))
            {
                currentAttributes   = layoutAttributes;
                offSetAdjustment    = itemHorizontalCenter - horizontalCenter;
            }
        }
    }

    CGFloat nextOffset          = proposedContentOffset.x + offSetAdjustment;

    proposedContentOffset.x     = nextOffset;
    CGFloat deltaX              = proposedContentOffset.x - self.collectionView.contentOffset.x;
    CGFloat velX                = velocity.x;

    if(deltaX == 0.0 || velX == 0 || (velX >  0.0 && deltaX >  0.0) || (velX <  0.0 &&  deltaX <  0.0)) {

    } else if(velocity.x >  0.0) {
        for (UICollectionViewLayoutAttributes *layoutAttributes in array)
        {
            if(layoutAttributes.representedElementCategory == UICollectionElementCategoryCell)
            {
                CGFloat itemHorizontalCenter = layoutAttributes.center.x;
                if (itemHorizontalCenter >  proposedContentOffset.x) {
                    proposedContentOffset.x = nextOffset + (currentAttributes.frame.size.width / 2) + (layoutAttributes.frame.size.width / 2);
                    break;
                }
            }
        }
    } else if(velocity.x <  0.0) {
        for (UICollectionViewLayoutAttributes *layoutAttributes in array)
        {
            if(layoutAttributes.representedElementCategory == UICollectionElementCategoryCell)
            {
                CGFloat itemHorizontalCenter = layoutAttributes.center.x;
                if (itemHorizontalCenter >  proposedContentOffset.x) {
                    proposedContentOffset.x = nextOffset - ((currentAttributes.frame.size.width / 2) + (layoutAttributes.frame.size.width / 2));
                    break;
                }
            }
        }
    }

    proposedContentOffset.y = 0.0;

    return proposedContentOffset;
}</code></pre>
        <h2>四、无限循环</h2>
        假设一共有5个item
        <dl>
            <dt>思路一、</dt>
            <dd>给CollectionView设置3个分区，每个分区有5个item，默认起始位置为第一个分区，当滑动到第0、2分区时，通过修改CollectionView的偏移量来回到中间分区，但是在修改contentSize时会出现卡顿的情况</dd>
            <dt>思路二、</dt>
            <dd>由于思路一中回到中间分区时会出现卡顿，所以将分区数量设置成一个较大值 例如：5001（由于CollectionView有重用机制所以并不会出现内存问题），默认为中间分区，即(5001 - 1) / 2，当滑动到0、5000分区时返回到中间分区</dd>
        </dl>
    </div>
</body>
</html>
