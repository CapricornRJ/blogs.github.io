<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>runtime-关联对象</title>
    <link rel="stylesheet" href="../pageStyle.css" media="all">
    <link rel="stylesheet" href="../article.css" media="all">
    <link rel="stylesheet" href="index.css" media="all">
</head>
<body>
    <div class="article">
        <h1 class="title">runtime-关联对象</h1>
        <blockquote>这里主要结合<a href="https://opensource.apple.com/source/objc4/">runtime源码</a>来理解：<br>    1、Associated Objects 的实现原理<br>    2、@property如何实现getter、setter方法<br>    3、Category无法添加实例变量的原因<br>参考链接：<br>    <a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/">Objective-C Associated Objects 的实现原理</a><br>    <a href="https://www.jianshu.com/p/44d12884e24e">iOS @property探究(二): 深入理解</a><br>    <a href="https://tech.meituan.com/DiveIntoCategory.html">深入理解Objective-C：Category</a></blockquote>
        <h2>一、主要方法</h2>
        <pre><code class="Objective-C">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);// 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象；
id objc_getAssociatedObject(id object, const void *key);// 用于获取关联对象
void objc_removeAssociatedObjects(id object);// 用于移除一个对象的所有关联对象</code></pre>
        <p>注：<code class="text-code">objc_removeAssociatedObjects</code> 函数我们一般是用不上的，因为这个函数会移除一个对象的所有关联对象，将该对象恢复成“原始”状态。这样做就很有可能把别人添加的关联对象也一并移除，这并不是我们所希望的。所以一般的做法是通过给 <code class="text-code">objc_setAssociatedObject</code> 函数传入 nil来移除某个已有的关联对象。</p>
        <h2>二、关联策略</h2>
        <p>在给一个对象添加关联对象时有五种关联策略可供选择：</p>
        <table>
            <tr>
                <th>关联策略</th>
                <th>等价属性</th>
                <th>说明</th>
            </tr>
            <tr>
                <td>OBJC_ASSOCIATION_ASSIGN</td>
                <td>@property (assign) <br> @property (unsafe_unretained)</td>
                <td>弱引用关联对象</td>
            </tr>
            <tr>
                <td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
                <td>@property (strong, nonatomic)</td>
                <td>强引用关联对象，且为非原子操作</td>
            </tr>
            <tr>
                <td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
                <td>@property (copy, nonatomic)</td>
                <td>复制关联对象，且为非原子操作</td>
            </tr>
            <tr>
                <td>OBJC_ASSOCIATION_RETAIN</td>
                <td>@property (strong, atomic)</td>
                <td>强引用关联对象，且为原子操作</td>
            </tr>
            <tr>
                <td>OBJC_ASSOCIATION_COPY</td>
                <td>@property (copy, atomic)</td>
                <td>复制关联对象，且为原子操作</td>
            </tr>
        </table>
        <p>2与4、3与5的差别在于操作是否具有原子性，这里只讨论前3种情况，对于操作的原子性不做展开讨论</p>
        <h2>三、关联对象释放逻辑</h2>
        <p>我们通过一个实验观察关联对象的释放逻辑，关键代码如下</p>
        <pre><code class="Objective-C">#import "ViewController+AssociatedObjects.h"
#import &ltobjc/runtime.h&gt

@implementation ViewController (AssociatedObjects)

#pragma mark - ViewController Object Associated Objects

- (NSString *)associatedObject_assign {
    return objc_getAssociatedObject(self, _cmd);
}

- (void)setAssociatedObject_assign:(NSString *)associatedObject_assign {
    objc_setAssociatedObject(self, @selector(associatedObject_assign), associatedObject_assign, OBJC_ASSOCIATION_ASSIGN);
}

- (NSString *)associatedObject_retain {
    return objc_getAssociatedObject(self, _cmd);
}

- (void)setAssociatedObject_retain:(NSString *)associatedObject_retain {
    objc_setAssociatedObject(self, @selector(associatedObject_retain), associatedObject_retain, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (NSString *)associatedObject_copy {
    return objc_getAssociatedObject(self, _cmd);
}

- (void)setAssociatedObject_copy:(NSString *)associatedObject_copy {
    objc_setAssociatedObject(self, @selector(associatedObject_copy), associatedObject_copy, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

#pragma mark - ViewController Class Associated Objects

+ (NSString *)associatedObject {
    return objc_getAssociatedObject([self class], _cmd);
}

+ (void)setAssociatedObject:(NSString *)associatedObject {
    objc_setAssociatedObject([self class], @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end</code></pre>
        <p>先将代码运行到28行，然后在通过<code class="text-code">watchpoint</code>给<code class="text-code">string_weak_assign</code> 、<code class="text-code">string_weak_retain</code> 和 <code class="text-code">string_weak_copy</code>设置观察点。正确设置好观察点后，将会在 <code class="text-code">console</code> 中看到如下的类似输出：</p>
        <img class="image-view" src="../Resource/runtime_associatedObject_1.png">
        <p>点击继续运行按钮，有一个观察点将被命中。我们先查看 <code class="text-code">console</code> 中的输出，通过将这一步打印的 <code class="text-code">old value</code> 和上一步的 <code class="text-code">new value</code> 进行对比，我们可以知道本次命中的观察点是 <code class="text-code">string_weak_assign</code> ，<code class="text-code">string_weak_assign</code> 的值变成了 0x0000000000000000 ，也就是 nil 。换句话说 <code class="text-code">self.associatedObject_assign</code> 指向的对象已经被释放了</p>
        <img class="image-view" src="../Resource/runtime_associatedObject_2.png">
        <p>点击屏幕，由于<code class="text-code">associatedObject_assign</code>已被释放，会导致Crash</p>
        <img class="image-view" src="../Resource/runtime_associatedObject_3.png">
        <p>接下来，我们点击 <code class="text-code">ViewController</code> 导航栏左上角的按钮，返回前一个界面，此时，又将有一个观察点被命中。同理，我们可以知道这个观察点是 <code class="text-code">string_weak_retain</code> 。我们查看左侧的调用栈，将会发现一个非常敏感的函数调用 <code class="text-code">_object_remove_assocations</code> ，调用这个函数后 <code class="text-code">ViewController</code> 的所有关联对象被全部移除。最终，<code class="text-code">self.associatedObject_retain</code> 指向的对象被释放。</p>
        <p>点击继续运行按钮，最后一个观察点 <code class="text-code">string_weak_copy</code> 被命中。同理，<code class="text-code">self.associatedObject_copy</code> 指向的对象也由于关联对象的移除被最终释放。</p>
        <img class="image-view" src="../Resource/runtime_associatedObject_4.png">
        <h2>四、实现原理</h2>
        <p>我们可以在 <code class="text-code">objc-references.mm</code> 文件中找到 <code class="text-code">objc_setAssociatedObject</code> 函数最终调用的函数：</p>
        <pre><code class="Objective-C">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {
    // retain the new value (if any) outside the lock.
    ObjcAssociation old_association(0, nil);
    id new_value = value ? acquireValue(value, policy) : nil;
    {
        AssociationsManager manager;
        AssociationsHashMap &associations(manager.associations());
        disguised_ptr_t disguised_object = DISGUISE(object);
        if (new_value) {
            // break any existing association.
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i != associations.end()) {
                // secondary table exists
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end()) {
                    old_association = j->second;
                    j->second = ObjcAssociation(policy, new_value);
                } else {
                    (*refs)[key] = ObjcAssociation(policy, new_value);
                }
            } else {
                // create the new association (first time).
                ObjectAssociationMap *refs = new ObjectAssociationMap;
                associations[disguised_object] = refs;
                (*refs)[key] = ObjcAssociation(policy, new_value);
                object->setHasAssociatedObjects();
            }
        } else {
            // setting the association to nil breaks the association.
            AssociationsHashMap::iterator i = associations.find(disguised_object);
            if (i !=  associations.end()) {
                ObjectAssociationMap *refs = i->second;
                ObjectAssociationMap::iterator j = refs->find(key);
                if (j != refs->end()) {
                    old_association = j->second;
                    refs->erase(j);
                }
            }
        }
    }
    // release the old value (outside of the lock).
    if (old_association.hasValue()) ReleaseValue()(old_association);
}</code></pre>
        <p>在看这段代码前，我们需要先了解一下几个数据结构以及它们之间的关系：<br>
            <br>
            <code class="text-code">AssociationsManager</code> 是顶级的对象，维护了一个从 <code class="text-code">spinlock_t</code> 锁到 <code class="text-code">AssociationsHashMap</code> 哈希表的单例键值对映射；<br>
            <code class="text-code">AssociationsHashMap</code> 是一个无序的哈希表，维护了从对象地址到 <code class="text-code">ObjectAssociationMap</code> 的映射；<br>
            <code class="text-code">ObjectAssociationMap</code> 是一个 C++ 中的 map ，维护了从 key 到 <code class="text-code">ObjcAssociation</code> 的映射，即关联记录；<br>
            <code class="text-code">ObjcAssociation</code> 是一个 C++ 的类，表示一个具体的关联结构，主要包括两个实例变量，_policy 表示关联策略，_value 表示关联对象。<br>
            每一个对象地址对应一个 <code class="text-code">ObjectAssociationMap</code> 对象，而一个 <code class="text-code">ObjectAssociationMap</code> 对象保存着这个对象的若干个关联记录。<br>
            <br>
            弄清楚这些数据结构之间的关系后，再回过头来看上面的代码就不难了。我们来看下面的流程图，一图胜千言：</p>
        <img class="image-view" src="../Resource/runtime_associatedObject_5.png">
        <h2>五、@property代码理解</h2>
        <blockquote>@property = ivar + getter + setter</blockquote>
        <p><code class="text-code">ivar</code>就是实例变量，编译器会帮我们自动生成名字为'_属性名'这样的实例变量，同时也会自动生成<code class="text-code">getter</code>和<code class="text-code">setter</code>方法</p>
        <p>有如下代码</p>
        <pre><code class="Objective-C">#import &ltFoundation/Foundation.h&gt

@interface Person : NSObject

@property (nonatomic, copy) NSString* name;
@property (nonatomic, assign) NSUInteger age;

@end

#import "Person.h"

@implementation Person

@end</code></pre>
        <p>可使用<code class="text-code">clang -rewrite-objc Person.m</code> 这个命令用于clang重写.m文件为.cpp文件。<br>主要代码如下：</p>
        <pre><code class="Objective-C">#ifndef _REWRITER_typedef_Person
#define _REWRITER_typedef_Person
typedef struct objc_object Person;
typedef struct {} _objc_exc_Person;
#endif

extern "C" unsigned long OBJC_IVAR_$_Person$_name;
extern "C" unsigned long OBJC_IVAR_$_Person$_age;
extern "C" unsigned long OBJC_IVAR_$_Person$_babyArray;
struct Person_IMPL {
	struct NSObject_IMPL NSObject_IVARS;
	NSString *_name;
	NSUInteger _age;
	NSArray *_babyArray;
};


// @property (nonatomic, copy) NSString* name;
// @property (nonatomic, assign) NSUInteger age;
// @property (nonatomic, strong) NSArray *babyArray;

/* @end */


// @implementation Person


static NSString * _I_Person_name(Person * self, SEL _cmd) { return (*(NSString **)((char *)self + OBJC_IVAR_$_Person$_name)); }
extern "C" __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);

static void _I_Person_setName_(Person * self, SEL _cmd, NSString *name) { objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _name), (id)name, 0, 1); }

static NSUInteger _I_Person_age(Person * self, SEL _cmd) { return (*(NSUInteger *)((char *)self + OBJC_IVAR_$_Person$_age)); }
static void _I_Person_setAge_(Person * self, SEL _cmd, NSUInteger age) { (*(NSUInteger *)((char *)self + OBJC_IVAR_$_Person$_age)) = age; }

static NSArray * _I_Person_babyArray(Person * self, SEL _cmd) { return (*(NSArray **)((char *)self + OBJC_IVAR_$_Person$_babyArray)); }
static void _I_Person_setBabyArray_(Person * self, SEL _cmd, NSArray *babyArray) { (*(NSArray **)((char *)self + OBJC_IVAR_$_Person$_babyArray)) = babyArray; }</code></pre>
        <p>在上面代码中发现：<br>
            1、<code class="text-code">typedef struct objc_object Person</code> 将Person定义为objc_object的结构体。而<code class="text-code">struct objc_object</code>结构体只有一个类型为<code class="text-code">Class</code>的<code class="text-code">isa</code>指针变量，此处就不做展开讨论了。</p>

        <pre><code class="Objective-C">struct objc_object {
    Class _Nonnull isa __attribute__((deprecated));
};</code></pre>
        <p>2、下面代码中定义了两个unsigned long类型的变量，这两个变量代表一个偏移量，值这两个实例变量在内存中存储的偏移量，通过这两个值就能够在内存中定位到这两个实例变量的位置。</p>
        <pre><code class="Objective-C">extern "C" unsigned long OBJC_IVAR_$_Person$_name;
extern "C" unsigned long OBJC_IVAR_$_Person$_age;</code></pre>
        <p>3、该结构体就是Person类实现，struct NSObject_IMPL结构体只有一个Class isa结构体指针变量，指向类对象，用于获取Person类的方法列表、实例变量列表、属性列表、版本等信息。可以看出，在底层代码中编译器帮我们自动生成了名为_name和_age的两个实例变量。</p>
        <pre><code class="Objective-C">struct Person_IMPL {
	struct NSObject_IMPL NSObject_IVARS;
	NSString *_name;
	NSUInteger _age;
};</code></pre>
        <p>4、getter、setter方法的底层实现</p>
        <blockquote>getter方法实现原理没有差别，都使用了偏移量 <code class="text-code">OBJC_IVAR_$_Person$_name</code>、<code class="text-code">OBJC_IVAR_$_Person$_age</code>、<code class="text-code">OBJC_IVAR_$_Person$_babyArray</code>来计算实例变量的存储位置并返回。</blockquote>
        <blockquote>setter方法实现原理：<br>
            1、copy:使用__OFFSETOFIVAR__(TYPE, MEMBER)宏定义来计算偏移量，计算出偏移量后使用objc_setProperty来设置实例变量_name的值。<br>
            2、assign、strong：与copy底层实现相比发现，没有声明objc_setProperty方法也没有使用该方法，而是直接计算出实例变量的偏移量后将指针赋给实例变量。</blockquote>
        <h2>六、Category无法添加实例变量的原因</h2>
        <p>1、category是无法添加实例变量的（category是在运行期决议的，因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>
        <p>2、我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了<br>    1)、类的名字（name）<br>    2)、类（cls）<br>    3)、category中所有给类添加的实例方法的列表（instanceMethods）<br>    4)、category中所有添加的类方法的列表（classMethods）<br>    5)、category实现的所有协议的列表（protocols）<br>    6)、category中添加的所有属性（instanceProperties）</p>
        <pre><code class="Objective-C">struct category_t {
    const char *name;
    classref_t cls;
    struct method_list_t *instanceMethods;
    struct method_list_t *classMethods;
    struct protocol_list_t *protocols;
    struct property_list_t *instanceProperties;
} category_t;</code></pre>
        <p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。</p>
    </div>
</body>
</html>